# Таблица связей

Можно сделать таблицу, хранящую все взаимосвязи родитель/дочерний элемент в дереве категорий:

| parent          | child             | depth |
|-----------------|-------------------|-------|
| Бытовая техника | Бытовая техника   | 0     |
| Бытовая техника | Стиральные машины | 1     |
| Бытовая техника | Холодильники      | 1     |
| Бытовая техника | Телевизоры        | 1     |
| Бытовая техника | однокамерные      | 2     |
| Бытовая техника | двухкамерные      | 2     |
| Холодильники    | Холодильники      | 0     |
| Холодильники    | однокамерные      | 1     |
| Холодильники    | двухкамерные      | 1     |


**Плюсы** - не нужны будут дорогие рекурсивные запросы, 
каким бы глубоким не было дерево, запрос на нахождение предка будет выполняться за оптимальное время.

**Минусы** - такая таблица будет занимать существенное количество памяти с ростом дерева. 
Необходимо будет при вставке новых данных/изменении отношений обновлять ее, 
для этого, допустим, придется применить триггеры.

# Дополнительное поле в таблице orders_goods с именем клиента

Также можем денормализовать данные, добавив дополнительное поле в `orders_goods`
с именем клиента, таким образом избавимся от необходимости в джойне с таблицей goods,
так как оттуда нам нужно только одно поле - `name`.


# Индексы

Индексы строятся для ускорения конкретных запросов. В наших запросах нет WHERE, ORDER BY,
выполнение которых можно было бы ускорить индексами. В запросе 1 есть join по orders_goods.goods_id,
можно было бы создать b-tree по этому полю, и это бы ускорило join.

Также, на мой взгляд, в нашей гипотетической таблице взаимосвязей дерева мы бы часто, скорее всего,
делали запрос, где в WHERE фигурировали поля child_id и depth 
(WHERE child_id = ? AND depth > ?) 
так что можно было бы построить b-tree индекс по (child_id, depth).





